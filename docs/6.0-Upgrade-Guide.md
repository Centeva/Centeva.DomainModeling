# Upgrading to 6.0

## Replacement Repository interfaces

The `IReadRepository`/`IRepository` interfaces no longer inherit from the those
provided by `Ardalis.Specification`.  The names and parameters of existing
methods are unchanged.

The `IAggregateRoot` generic constraint has been removed from the definition of
these interfaces, to allow use on projects that are not using aggregates.

## Default Entity Framework Core repository implementation

The package `Centeva.SharedKernel.EFCore` contains `BaseRepository` which is an
implementation of the `IRepository` interface for use with Entity Framework
Core.  This is an abstract class, so you must derive from it within your own
applications:

```csharp
public class EfRepository<T> : BaseRepository<T>, IRepository<T> where T : class, IAggregateRoot
{
    public EfRepository(ApplicationDbContext dbContext) 
      : base(dbContext) { }
}
```

If you are using a Clean Architecture-like project structure for your
application, then add the `Centeva.SharedKernel.EFCore` to your Infrastructure
project, implement your repository class as above, and ensure that dependency
injection is configured as before.

## Additional repository methods for mapping via Expressions

To separate mapping logic from query logic, the following methods in
`IReadRepository` have overloads that take expressions for mapping your Entity
to another type (such as a DTO):

* ListAsync
* FirstOrDefaultAsync
* SingleOrDefaultAsync

A simple example looks like this:

```csharp
public class PersonDto
{
    public int Id { get; set; }
    public string? Name { get; set; }

    public static Expression<Func<Person, PersonDto>> FromPerson = 
        person => new PersonDto
        {
            Id = person.Id, 
            Name = person.Name
        };
}

// ...

var dto = await personRepository.FirstOrDefaultAsync(specification, PersonDto.FromPerson);
```

This will result in the generated SQL query only containing the columns needed
to populate the destination type.

## Extended support for mapping via AutoMapper

The `IProjectedReadRepository` interface defines the following methods that
return entities mapped to another type:

* ListProjectedAsync
* FirstOrDefaultProjectedAsync
* SingleOrDefaultProjectedAsync

The package `Centeva.SharedKernel.EFCore.AutoMapper` contains
`BaseProjectedRepository` which is an implementation of the `IRepository` and
`IProjectedReadRepository` interfaces for use with Entity Framework Core.  This
is an abstract class, so you must derive from it within your own applications:

```csharp
public class EfRepository<T> : BaseProjectedRepository<T>, IRepository<T>, IProjectedReadRepository<T> where T : class, IAggregateRoot
{
    public EfRepository(ApplicationDbContext dbContext, IConfigurationProvider mappingConfigurationProvider) 
      : base(dbContext, mappingConfigurationProvider) { }
}
```

You will need to configure AutoMapper in your application's dependency injection
configuration.

A simple example using the DTO above (and assuming AutoMapper is configured with
a mapping from `Person` to `PersonDto`) looks like this:

```csharp
var dto = await personRepository.FirstOrDefaultProjectedAsync<PersonDto>(specification);
```

## Domain event improvements

The `IDomainEventDispatcher.DispatchAndClearEvents` method now accepts a
cancellation token as its last parameter and the implementation passes the token
along to the event publisher.

The `Centeva.SharedKernel.EFCore` package includes an extension method
`GetEntitiesWithEvents` for `DbContext` that can be used to obtain the list of
tracked entities that contain domain events:

```csharp
// In your DbContext:

public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    var result = await base.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

    await _domainEventDispatcher.DispatchAndClearEvents(this.GetEntitiesWithEvents(), cancellationToken);

    return result;
}
```
