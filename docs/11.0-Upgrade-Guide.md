# Upgrading to 11.0

Version 11 introduces some breaking changes that require attention when
upgrading from previous versions. Please follow the guide below to ensure a
smooth transition.

To summarize, the main changes are:

* The minimum supported .NET version is now .NET 8.0.
* Domain event dispatching has been split into two separate packages to allow
  choice between MediatR and Mediator libraries.
* The `Id` property on `BaseEntity` is now init-only.
* The EF Core interceptor for domain event dispatching is now the only method
  for dispatching domain events.

## Check target .NET version

The minimum supported .NET version is now .NET 8.0.

## Install your desired Domain Event dispatcher package

There are now two separate implementations of domain event dispatching so that
you can choose between the commercially-licensed (for version 13.0 and up)
[MediatR](https://mediatr.io/) library and the open-source
[Mediator](https://github.com/martinothamar/Mediator) library.

* Centeva.DomainModeling.MediatR
* Centeva.DomainModeling.Mediator

### If you are using MediatR

* Ensure that you meet the licensing requirements for using MediatR in your
  project if you are using version 13.0 or later.
* Install the `Centeva.DomainModeling.MediatR` NuGet package in your projects
  that contain your domain event classes and service registration.
* Ensure that your domain event classes inherit from
  `Centeva.DomainModeling.MediatR.BaseDomainEvent` instead of the now-removed
  `Centeva.DomainModeling.BaseDomainEvent`.
* Ensure that your domain event handlers implement the `INotificationHandler<T>`
  interface provided by the MediatR library.
* Update your Dependency Injection configuration, if needed, to register the
  `MediatRDomainEventDispatcher` as the implementation of
  `IDomainEventDispatcher`:

  ```csharp
  using Centeva.DomainModeling.MediatR;

  // ... other setup code

  builder.Services.AddMediatR(...); // Register MediatR handlers
  builder.Services.AddSingleton<IDomainEventDispatcher, MediatRDomainEventDispatcher>();
  ```

### If you are using Mediator

* Install the `Centeva.DomainModeling.Mediator` NuGet package in your projects
  that contain your domain event classes and service registration.
* Ensure that your domain event classes inherit from
  `Centeva.DomainModeling.Mediator.BaseDomainEvent` instead of the now-removed
  `Centeva.DomainModeling.BaseDomainEvent`.
* Ensure that your domain event handlers implement the `INotificationHandler<T>`
  interface provided by the Mediator library.
* Update your Dependency Injection configuration, if needed, to register the
  `MediatorDomainEventDispatcher` as the implementation of
  `IDomainEventDispatcher`:

  ```csharp
  using Centeva.DomainModeling.Mediator;

  // ... other setup code

  builder.Services.AddMediator();
  builder.Services.AddSingleton<IDomainEventDispatcher, MediatorDomainEventDispatcher>();
  ```

## Replace any direct sets to `BaseEntity.Id` with init-only assignments

The `Id` property on `BaseEntity` is now init-only to better align with best
practices for immutable identifiers.  This means that the `Id` property can only
be set during object initialization and not modified afterwards.

If you have code that sets the `Id` property after the entity has been created,
you will need to update it to set the `Id` during initialization, for example:

```csharp
// Before
var entity = new MyEntity();
entity.Id = Guid.NewGuid();

// After
var entity = new MyEntity
{
    Id = Guid.NewGuid()
};
```

## Use the EF Core Interceptor for Domain Event dispatching

The previously obsoleted (in 10.2.0) `DbContext.GetEntitiesWithEvents()`
extension method has been removed.  Use the `DispatchDomainEventsInterceptor` as
described below.

If you have any code in your DbContext that looks like the below, remove it,
along with any injection of `IDomainEventDispatcher` into your DbContext:

```csharp
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    var result = await base.SaveChangesAsync(cancellationToken).ConfigureAwait(false);

    await _domainEventDispatcher.DispatchAndClearEvents(this.GetEntitiesWithEvents(), cancellationToken);

    return result;
}
```

Register the `DispatchDomainEventsInterceptor` in your Dependency Injection
setup for EF Core:

```csharp
builder.Services.AddSingleton<DispatchDomainEventsInterceptor>();
builder.Services.AddDbContext<ApplicationDbContext>((sp, options) =>
{
    options.AddInterceptors(sp.GetRequiredService<DispatchDomainEventsInterceptor>());
    options.UseSqlServer(connectionString);
    // ... other options
});
```

Ensure that you are calling only `SaveChangesAsync()` on your DbContext as the
interceptor relies on this method to trigger the domain event dispatching.  If
you are calling `SaveChanges()` (synchronous version), you will need to update
your code to call the asynchronous version.
